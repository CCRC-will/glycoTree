package svgConvert;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;

import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner; 

/**
 * SVGflatten parses an svg file produced by GlyTouCan and generates another svg file that
 * generates essentially the same image, while removing unnecessary object layering and
 * assigning unique id attributes of each shape node, edge, and text annotation in the image.
 * This allows more than one svg image to be rendered in a single browser window and facilitates
 * programmatic access (e.g., click events) to each svg element by javascript code.
 * The id's are generated by reference to the csv file that uses a canonical representation 
 * to describe the structure in the original svg file.  In this case, each svg node (residue) will
 * be assigned a semantic id consisting of a 'type' "R"|"L"|"LI" the structure accession, and the 
 * canonical id of the residue - for example, "R-G95575GS:NA". Alternatively a csv file generated
 * directly from a GlycoCT file can be used as input, in which case the residue indices
 * inherited from the GlycoCT encoding of the structure will be used in the semantic id,
 * for example, "R-G95575GS:1".  In either case, if the svg residue is not mappable to the csv 
 * encoding (e.g., if the path from the residue to the root residue is not fully defined) the svg 
 * residue will be assigned a semantic id that includes its svg id, preceeded by the character "S", 
 * e.g.,  "R-G95575GS:S7"<br>
 * An output csv file that maps all ID replacements is also generated.
 * <br>
 *  Copyright 2020 William S York
 *  <br>
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  <br>
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  <br>
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
 * <br>
 * @author wsyork
 *
 */
public class SVGflatten {
	
	/**
	 * the verbosity of the output to stdout
	 */
	public static int v = 9;

	public static StringBuilder mapStr; 
	public static String mapFileName = "";
	
	// The following Strings are declared globally, and reinitialized for each new structure
	//  This is not optimal  - Possible improvement: declare all three locally and put into 
	//  a locally declared HashMap, pass this Map as a method argument ...
	//  A bit more verbose, but keeps data local - TODO later
	public static String nString = "";
	public static String lString = "";
	public static String aString = "";
	public static Boolean addReducingAnomer = false;


	/**
	 * The core execution method, which collects data and generates svg output.
	 * Command line arguments (args):<br>
	 * -l: the name of a file containing a list of svg input files to process<br>
	 * -s: the name of a single svg file encoding a glycan image to process<br>
	 * -a: a String specifying the specific type of the output (e.g., "gTree.v2.0") - used
	 *  in naming the output file - to prevent file-name degeneracy<br>
	 * -c: the name of the directory holding the csv files used in batch processing -
	 * if -c is not specified, csv files are fetched from the same directory that
	 * holds the corresponding svg input file - if the csv file cannot be found, svg
	 * objects are assigned id's ending in the numerical part of their original svg id's<br>
	 * -o: the name of the directory to which the generated svg files are written -
	 * if -o is not specified, svg files are written to the same directory that
	 * holds the corresponding svg input file<br>
	 * -v: verbosity has a value of 0-9. For batch processing, use "-v 0" or "-v 1" 
	 * to minimize the information that is written to std out<br>
	 * -r: add a &lt;text&gt; tag to the new svg encoding to render the reducing end anomeric form<br>
	 * -m: the name of the mapping file (records replacement of svg IDs with semantic id's)
	 * @param args	 An array of parameters passed to the program at initiation
	 */
	public static void main(String args[]) {
		mapStr = new StringBuilder("accession,svg_id,semantic_id");
		
		
		String svgFileName = "";
		String listFileName = null;
		String outDir = "./";
		Boolean outDirSet = false;
		String csvDir = "";
		Boolean csvDirSet = false;
		String versionStr = "unbloated";
		Boolean versionSet = false;
		
		String svgEncoding = "";

		// get command line arguments
		for (int i = 0; i < args.length; i++) {
			char c1 = args[i].charAt(0);
			char c2 = '0';
			if (args[i].length() > 1)
				c2 = args[i].charAt(1);
			// String s = "";
			// if (i < args.length - 1) s = args[i+1];
			// System.out.printf("%d: %s (%s)\n", i, args[i], s);
			if (c1 == '-') {
				switch (c2) {
					case 's':
						i++;
						svgFileName = args[i];
						break;
					case 'l':
						i++;
						listFileName = args[i];
						break;
					case 'm':
						i++;
						mapFileName = args[i];
						break;
					case 'a':
						i++;
						versionStr = args[i];
						// versionSet = true;
						break;
					case 'c':
						i++;
						csvDir = args[i];
						csvDirSet = true;
						break;
					case 'o':
						i++;
						outDir = args[i];
						outDirSet = true;
						break;
					case 'r':
						i++;
						if (args[i].matches("1")) addReducingAnomer = true;
						break;
					case 'v':
						i++;
						v = Integer.valueOf(args[i]);
						break;
					default:
						break;
				}
			}
		}
		
		/**
		 * an ArrayList of the svg files to be processed
		 */
		ArrayList<String> files = new ArrayList<String>();
		if (listFileName != null) {
			// open and parse the list file, putting elements in the ArrayList "files"
			if (v > 0)
				System.out.printf("\n\n###### Using a list (%s) containing input files ######\n", listFileName);
			files = parseListFile(listFileName);
		} else if (svgFileName != null) {
			if (v > 0)
				System.out.printf("\n\n###### Using a single specified input file (%s) ######\n", svgFileName);
			// just put the svgFileName into the files ArrayList
			files.add(svgFileName);
		} else {
			System.out.printf("** No valid svg input files ** \n");
		}

		for (Iterator<String> f_iter = files.iterator(); f_iter.hasNext();) {
			svgFileName = f_iter.next(); // keep this for later use
			File inFile = new File(svgFileName);
			String inputDir = inFile.getParent();
			String inputFileName = inFile.getName();
			String[] dotSplit = inputFileName.split("[.]");
			if (!csvDirSet) csvDir = new String(inputDir);
			String glycanName = dotSplit[0];
			String csvFileName = csvDir + "/" + glycanName + ".csv";
			if (!outDirSet) outDir = new String(inputDir);
			// if (!versionSet) versionStr = new String(inputDir);
			String outFileName = outDir + "/" + dotSplit[0] + "." + versionStr + ".svg";
			// still need to generate the out file, including version ...

			if (v > 0) System.out.printf("\n\n#### Processing %s ####", inputFileName);

			if (v > 3) {
				System.out.printf("\n  svg full fileName: %s", svgFileName);
				System.out.printf("\n  inputDir: %s", inputDir);
				System.out.printf("\n  csvFileName: %s", csvFileName);
				System.out.printf("\n  outFileName: %s", outFileName);
			}
			svgEncoding = processData(csvFileName, svgFileName );	
			if (v > 3) System.out.printf("\n\n%s\n",svgEncoding);
			
			// write svgEncoding to output file
			writeData(svgEncoding, outFileName);
			
			// write ID mapping to output file
			if (v > 3) System.out.printf("\n\n###### Mappings #####\n\n %s", mapStr.toString());
			if (mapFileName.length() > 0) writeData(mapStr.toString(), mapFileName);
		}
		
	} // end of main()
	
	/**
	 * reads a glycoTree file in csv format to fetch each line as a String in 
	 * a String[] array.
	 * @param fn the fully-specified name of the csv file
	 * @return a String[] array containing the lines of the file as its elements
	 */
	public static String[] readCSV(String fn) {
		ArrayList<String> fileLines = new ArrayList<String>();
		File file = new File(fn);
		if (file.exists()) {
			try {
				Scanner input = new Scanner(file).useDelimiter("\n");
				while (input.hasNext()) {
				String line = input.next();
					if (v > 5) System.out.printf("\nReading line:    %s", line);
					fileLines.add(line);
				}
				input.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		} else {
			System.out.printf("\n\n ***** File %s does not exist! *****", fn);
		}	
		
		String[] csvLines = new String[fileLines.size()];
		csvLines = fileLines.toArray(csvLines);
		return(csvLines);
	} // end of method readCSV()
	
	
	/**
	 * Generates a list of file names by reading an input file whose name is specified by the String fn
	 * @param fn A String containing the name of a file listing input (svg) files  
	 * @return An ArrayList containing names of svg input files to be processed
	 */
	public static ArrayList<String> parseListFile(String fn) {
		ArrayList<String> result = new ArrayList<String>();
		File file = new File(fn);
		if (file.exists()) {
			try {
				Scanner input = new Scanner(file).useDelimiter("\n");
				while (input.hasNext()) {
					String line = input.next();
					result.add(line);
					if (v > 5)
						System.out.printf("\nAdding file %s", line);
				}
				input.close();
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} else {
			System.out.printf("file %s does not exist", fn);
		}
		return (result);
	} // end of parseListFile


	/**
	 * Writes String strToWrite to file instantiated with fileName
	 * @param strToWrite the String to be written
	 * @param fileName the name of the file to be written to
	 */
	public static void writeData(String strToWrite, String fileName) {
		if (v > 3)
			System.out.printf("\n# Writing to file: %s", fileName);
		try {
			BufferedWriter w = new BufferedWriter(new FileWriter(fileName));
			w.write(strToWrite);
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
			System.out.printf("IO exception for file %s\n", fileName);
		}
	} // end of writeData()
	
	/**
	 * parses an input svg file and generates a new svg file in which unnecessary
	 * layering has been removed and svg objects have been assigned unique semantic id's,
	 * based on information contained in the corresponding glycoTree csv file
	 * @param cFileName the name of the csv file to process
	 * @param sFileName the name of the svg file to process
	 * @return a String (to be written to a new file) with the semantically annotated svg encoding
	 */
	public static String processData(String cFileName, String sFileName ) {
		
		/**
		 * a String holding the svg encoding to be written to a new file
		 */
		String svgStr = "";

		// csv processing variables
		/**
		 * a HashMap associating the residue node id's in the original svg file to canonical glycan residues
		 */
	    Map<String, String> canResIDs= new HashMap<String, String>();

		/**
		 * a HashMap associating the edge id's in the original svg file to canonical glycan residues
		 */
	    Map<String, String> canLinkIDs= new HashMap<String, String>();
	    
		/**
		 * a HashMap associating the linkage annotation id's in the original svg file to canonical glycan residues
		 */
	    Map<String, String> canAnnIDs= new HashMap<String, String>();
		
	    // svg processing variables
	    
	    /**
	     * a StringBuilder that holds encoding of all newly-generated edge nodes (linkages)
	     */
	    StringBuilder lStr = new StringBuilder(); 
	    
	    /**
	     * a StringBuilder that holds encoding of all newly-generated residue nodes
	     */
		StringBuilder nStr = new StringBuilder();  
		
	    /**
	     * a StringBuilder that holds encoding of all newly-generated link annotation nodes
	     */		
		StringBuilder aStr = new StringBuilder();  
		
	    /**
	     * a StringBuilder that holds the first lines of the new svg file (e.g., header information)
	     */	
		StringBuilder headStr = new StringBuilder(); 
		
	    /**
	     * a StringBuilder that holds the last lines of the new svg file (e.g., tag closings)
	     */	
		StringBuilder tailStr = new StringBuilder("\n  </g>\n</svg>\n<!-- ## End of svg encoding ##-->\n\n");
		
		/**
		 * a String holding the key for the root residue of the csv encoding
		 * @default zero ("0") which points to no residue
		 */


       // ###### process csv ######
		
		if (v > 0) {
			System.out.printf("\n\n### Processing csv file [%s] ###", cFileName);
		}
		Map<String, Map<String, String>> gtResidues = new HashMap<String, Map<String, String>>();
		Map<String, Map<String, String>> svgResidues = new HashMap<String, Map<String, String>>();
		
		String[] csvLines = readCSV(cFileName);
		for (int i = 1; i < csvLines.length; i++) { // skip the header line where i == 0
			String[] vals = csvLines[i].split(",");
			String id = vals[2];
			String name = vals[3];
			String anomer = vals[4];
			String parent = vals[7];
			String site = vals[8];

			if (v > 5) System.out.printf("\nAdding csv residue[%s] %s with parent %s and site %s", id, name, parent, site);
			Map<String, String> residue = new HashMap<String, String>();
			residue.put("id", id);
			residue.put("name", name);
			residue.put("anomer", anomer);
			residue.put("parent", parent);
			residue.put("site", site);
			gtResidues.put(id, residue);

		}
		

		// ##### process svg #####
		
		// find accession by splitting the svgFileName
		String[] fnPath = sFileName.split("[/]");
		String fn = fnPath[fnPath.length - 1];
		String accession = fn.split("[.]")[0];
		
		headStr.append("<?xml version=\"1.0\"?>\n" +
			"<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN' 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>");
		headStr.append("\n<!-- ## svg encoding translated from file " + fn + " ## -->");


		if (v > 0) {
			System.out.printf("\n\n### Processing svg file [%s] ###", sFileName);
			System.out.printf("\n  Accession: %s", accession);
		}
		
		
		try {

			File svgFile = new File(sFileName);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			
			// override downloading the DTD, which causes failure when it is not available (usually the case)
			dbFactory.setValidating(false);
			dbFactory.setNamespaceAware(true);
			dbFactory.setFeature("http://xml.org/sax/features/namespaces", false);
			dbFactory.setFeature("http://xml.org/sax/features/validation", false);
			dbFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-dtd-grammar", false);
			dbFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);

			
			
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(svgFile);
			Node sNode = doc.getDocumentElement();
			sNode.normalize();
			Element svgElement = (Element) sNode;
			String svgStyle = svgElement.getAttribute("style");
			if (v > 3) {
				System.out.printf("\n  SVG Root Node is a <%s> tag", sNode.getNodeName());
				System.out.printf("\n  svgStyle:\n   %s", svgStyle);
			}
			


			NodeList gList = svgElement.getElementsByTagName("g");
			int tCount = 1;

			for (int gIndex = 0; gIndex < gList.getLength(); gIndex++) {
				Node gNode = gList.item(gIndex);
				if (v > 3) System.out.printf("\n\n\n  <%s> Element[%d]:", gNode.getNodeName(), gIndex);

				if (gNode.getNodeType() == Node.ELEMENT_NODE) {
					Element gElement = (Element) gNode;

		        	String gStyle = gElement.getAttribute("style");
		        	String gStr = "\n    <g style=\"" + gStyle + "\">";
		        	// get the descendants of gElement 
		    		NodeList ch = gElement.getElementsByTagName("*");
		    		
			        Boolean gHasID = gElement.hasAttribute("ID");
			        if (gHasID) {
			        	String gID = gElement.getAttribute("ID");
			        	gStr = new String("\n    <g style=\"" + gStyle + "\" id=\"" + gID + "\">");
			        	// parse the ID
			        	// gType defines the kind of object wrapped by the <g> tag
			        	//   possible values are: "R" (residue); "L" (link [edge]); "LI" (Link annotation); "B" (bracket)
			        	String gType = gID.split("-")[0].toUpperCase();	
			        	
			        	String key = "";
			        	if (gType.matches("B") ) { // brackets are NOT residues
			        		key = "B";
				        	gStr = new String("\n    <g style=\"" + gStyle + "\">");
			        	} else {
			        		key = addResidue(gID, svgResidues);
			        		if (v > 3) {
			        			System.out.printf("\n    Processing svg residue with key %s", key);
			        			System.out.printf("\n    gID is %s", gID);
			        			System.out.printf("\n    gStyle is %s", gStyle);
			        			System.out.printf("\n    gType is %s", gType);
			        			System.out.printf("\n    accession is %s", accession);
			        		}
			        	}
			        	
			        	// switch on value of gType
			    		String newID = "not ready"; // newID will be set upon mapping of svg to csv
			        	switch (gType) {
			        	case "R": // gElement wraps a residue (but rarely some text)
			        		String type_Result = type_R(gID, ch, gStr, svgResidues.get(key), key );
			        		nStr.append(type_Result );
			        		if ( type_Result.contains("text-anchor" ) ) { // CANNOT have a pure text node in svgResidues
			        			svgResidues.remove(key);
			        		}
			        		break;
			        	case "L": // gElement wraps a link
			        		lStr.append(type_L(gID, ch, gStr, svgResidues.get(key)) );
			        		break;
			        	case "LI": // gElement wraps a link annotation
			        		aStr.append(type_LI(gID, ch, gStr, svgResidues.get(key)) );
			        		break;
			        	case "B":
			        		lStr.append(type_B(ch, gStr) );
			        		break;
			        	default:
			        	}
			        	

			        } else { // the <g> Element has no ID: usually uninteresting, but may contain an image-bounding box
			        	Node fcn = gElement.getFirstChild();
			        	Element fce = (Element) fcn;

			        	String fcnType = fcn.getNodeName();
			        	if (v > 3) {
			        		System.out.printf("\n    no ID Attribute");
				        	System.out.printf("\n    first child Node is a <%s>", fcnType);
			        	}

			        	// the dimensions of the image are defined by a <g> tag with no id and whose first child is a <rect> 
			        	if (fcnType.compareTo("rect") == 0) {
			        		String h = fce.getAttribute("height");
			        		String w = fce.getAttribute("width");
			        		String svgID = accession + "_svg";
			        		String temp = "\n<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\"  xmlns=\"http://www.w3.org/2000/svg\" " + 
			        				"id=\""  + svgID + "\" height=\"" + h + "\" width=\"" + w + "\"  style=\"" + svgStyle + "\" >";
			        		if (v > 3) {
			        			System.out.printf("\n    Image boundary <rect>\n      height: %s\n      width: %s", h, w);
			        			System.out.printf("\n    <svg> tag string:%s", temp);
			        		}
			        		headStr.append(temp); 
			    			headStr.append("\n  <g>");
			    			gStr = new String("\n    <g style=\"" + gStyle + "\" id=\"C-" + accession + ":0\" >");
			    			NamedNodeMap fcAtts = fce.getAttributes();
			    			String shapeAtts = "";
			    			for (int j = 0; j < fcAtts.getLength(); j++ ) if (fcAtts.item(j).toString().contains("style") == false) {
			    				if (v > 3) 
			    					System.out.printf("\n      %s", fcAtts.item(j));
			    				shapeAtts = shapeAtts.concat(" " + fcAtts.item(j).toString());
			    			}
			    			shapeAtts = shapeAtts.concat(" style=\"fill:rgb(255,255,255); stroke:none;\" ");
			    			String bStr = gStr + "\n      <" + fcn.getNodeName() + shapeAtts + "/>\n    </g>";
			    			headStr.append(bStr);
			        	}
			        	
			        	// some text is defined as a path, with no associated id
			        	if (fcnType.compareTo("path") == 0) {
			        		String tIndex = "text" + tCount++;
			        		if (v > 4) 
			        			System.out.printf("\n    found unindexed text (%s)", tIndex);
			        		// create nullRes to pass to type_LI - it won't be modified
			        		Map<String, String> nullRes = new HashMap<String, String>();
			        		// nullRes.put("null",  "null");
			        		String nullID = "none";
			        		aStr.append(type_LI(nullID, ch, gStr, nullRes) );
			        	}


			        }

				}
			}
			
			// get roots and if necessary assign their parents 

		    Map<String, String> gtRoot = getRoot(gtResidues);
		    Map<String, String> svgRoot = getRoot(svgResidues);
		    String anomerChar = "";
		    // if (gtRoot.get("anomer") != null && !gtRoot.get("anomer").isEmpty()) {
		    if (gtRoot != null && !gtRoot.isEmpty()) {
		    	anomerChar = gtRoot.get("anomer");
		    }
		    if (v > 5) {
		    	System.out.printf("\n\n    Assigned gt root anomer %s", anomerChar);	    	
		    	System.out.printf("\n    Assigned svg root: %s", svgRoot.toString());
		    	System.out.printf("\n     svg root coordinates: (%s,%s)", svgRoot.get("x"), svgRoot.get("y"));
		    	showMap(gtResidues, "gTreeResidues");
				showMap(svgResidues, "svgResidues");
		    }

		    if (addReducingAnomer) {  // GENERATE REDUCING ANOMER ANNOTATION
		    	if (svgRoot.get("x") != null && !svgRoot.get("x").isEmpty()) {

		    		Double x = Double.parseDouble(svgRoot.get("x")) + 30;
		    		Double y = Double.parseDouble(svgRoot.get("y")) + 15;
		    		String rootAnomer = "";

		    		switch(anomerChar) {
		    		case "a":
		    			rootAnomer = "&#x03B1;";
		    			break;
		    		case "b":
		    			rootAnomer = "&#x03B2;";
		    			break;
		    		default:
		    			break;
		    		}

		    		String anomerString = "\n    <g style=\"fill:white; text-rendering:optimizeSpeed;\">" +
		    				"\n      <text style=\"fill:black; stroke:none;  font-size:12px; font-family:'Serif';\" x=\"" +
		    				x + "\" y=\"" + y + "\" text-anchor=\"middle\">" + rootAnomer + "</text>" +
		    				"\n    </g>";
		    		aStr.append(anomerString);
		    	}
		    }
		    
		    lString = lStr.toString();
		    nString = nStr.toString();
		    aString = aStr.toString();

		    if (v > 5) System.out.printf("\n\n  Assigning new IDs to mappable SVG objects");
		    if ( gtResidues.isEmpty() ) {
		    	System.out.printf("\n***** Cannot map residues to csv data for %s; using svg IDs in semantic ids *****", accession);
		    } else {
			    mapTheIDs(gtResidues, svgResidues, gtRoot, svgRoot, accession);		    	
		    }

		    if (v > 5) System.out.printf("\n\n  Cleaning up unmappable IDs in SVG objects");
		    cleanUpIDs(svgResidues, accession);

			svgStr = String.format("%s%s%s%s%s\n", headStr, lString, nString, aString, tailStr);
			
		} catch (Exception e) {
			e.printStackTrace();
		}

		return(svgStr);
	}   // end of method processData()

	
	/**
	 * generates a printout of the elements of a Map of Maps, including all keys and values
	 * @param theMap a Map of Maps to be printed
	 * @param mapName a String holding the name of the Map to be printed
	 */
	public static void showMap(Map<String, Map<String, String>> theMap, String mapName) {
		System.out.printf("\n\nMap: %s", mapName);
		for (String k1 : theMap.keySet()) {
			System.out.printf("\n  %s[%s]",  mapName, k1);
			Map<String, String> subMap = theMap.get(k1);
			for (String k2 : subMap.keySet() ) {
				System.out.printf("\n    %s: %s", k2, subMap.get(k2));
			}
		}
	} //  end of method showMap()
	
	
	/**
	 * assigns semantic IDs to svg &lt;g&gt; "R", "L" and "LI" objects that cannot be mapped to a residue 
	 * in the csv input file
	 * @param svgMap a Map of Maps holding the residues specified by the original svg encoding
	 * @param accession the accession of the glycan whose image is being processed
	 */
	public static void cleanUpIDs(Map<String, Map<String, String>> svgMap, String accession) {
		// assign unique IDs to all residues and links that do not have canonical IDs
		for (String svgKey : svgMap.keySet() ) {
			Map<String, String>svgRes = svgMap.get(svgKey);
			if (!svgRes.containsKey("canonicalID")) {
				String id = svgRes.get("id");
				nString = new String(replaceID(nString, id, svgRes, "resID", "R", accession, "S") );
				lString = new String(replaceID(lString, id, svgRes, "linkID", "L", accession, "S") );
				aString = new String(replaceID(aString, id, svgRes, "annID", "LI", accession, "S") );
			}
		}
	} // end of method cleanUpIDs()
	
	
	

	/**
	 * fetches the root residue in a tree defined by a Map of Maps
	 * @param theMap a Map of Maps to be probed
	 * @return a Map holding the the root residue and its properties
	 */
	public static Map<String, String> getRoot(Map<String, Map<String, String>> theMap) {
		// the root has parent = "0" or parent is null
		for (String k1 : theMap.keySet() ) {
			Map<String, String> theRes = theMap.get(k1);
			if (theRes.containsKey("parent") ) {
				// the residue (usually a gTree object) has a parent attribute
				if (theRes.get("parent").matches("0") )
					return(theRes);
			} else {
				// the residue (usually an svg object) has NO parent attribute
				theRes.put("parent", "0");
				return(theRes);				
			}

		}
		
		// the following is reachable only if no root can be found
		return(null);
	} // end of method getRoot()
	
	
	/**
	 * replaces the object id of an &lt;svg&gt; child element with another id, passed as an argument
	 * @param processedStr a String that is to be modified by replacing the id
	 * @param replacementID a String holding the new ID
	 * @param svgRes the Map holding the &lt;svg&gt; residue and its properties
	 * @param key String specifying the HashMap key ("resID", "linkID", or "annID") for the specific type of svg residue ID 
	 * svg residue ID to be modified - e.g., key "linkID" points to something like "r-1:3,2")
	 * @param type a String specifying the type of &lt;svg&gt; element corresponding (R or L or LI)
	 * @param accession the accession of the glycan being processed
	 * @param preID a String to be placed before the index part of the semantic id: empty ("") for 
	 * mappable residues or "S" (i.e., original svg index) for ummappable residues
	 * @return the modified version of the processed String
	 */
	public static String replaceID(String processedStr, String replacementID, Map<String, String> svgRes, String key,
			String type, String accession, String preID) {
		// add argument, Boolean keep to keep the svg index part of the id, e.g., l-1:3,4 -> L-Gxxxxxxx:3,4
		String result = new String(processedStr);
		
		if (svgRes.containsKey(key)) {
			// edit processedStr
			String oldID = svgRes.get(key);
			String newID  = type + "-" + accession + ":" + preID + replacementID;
			if (v > 5) System.out.printf("\n    Replacing SVG id %s with new id %s",  oldID, newID);
			
			mapStr.append("\n" + accession + ",\"" + oldID + "\"," + newID);

			String prefix = processedStr.substring(0, processedStr.indexOf(oldID));
			String suffix = processedStr.substring(processedStr.indexOf(oldID) + oldID.length(), processedStr.length());

			result = new String(prefix + newID + suffix);
		}
		
		return(result);

	} // end of method replaceID()
	
	
	
	/**
	 * maps ids of the &lt;svg&gt; elements to residues in the glycoTree encoding, allowing the &lt;svg&gt; elements to be modified
	 *   by changing their original ids to semantic ids
	 * @param gtMap a Map of Maps specifying a tree containing the residues specified in the glycoTree csv file
	 * @param svgMap a Map of Maps specifying a tree containing the residues specified in the svg file
	 * @param thisGTres the glycoTree residue that is the focus of this instance of mapIDs() - 
	 *  mapTheIDs() is recursive, so multiple instances (one per glycoTree residue) of this method are invoked
	 * @param thisSVGres the &lt;svg&gt; encoded residue that is the focus of this instance of mapIDs()
	 * @param accession the accession of the glycan being processed - required for semantic annotation
	 */
	public static void mapTheIDs(Map<String, Map<String, String>> gtMap, Map<String, Map<String, String>> svgMap,
			Map<String, String> thisGTres, Map<String, String> thisSVGres, String accession) {
		// recursive parallel depth-first traversal
		// assume gtRes and svgRes match, based on initial call and logic below
		if (v > 5) System.out.printf("\n  Assigning id %s to SVG residue %s", thisGTres.get("id"), thisSVGres.get("id"));
		
		// replace IDs in Strings writ method to do this ...
		String canonicalID = thisGTres.get("id");
		thisSVGres.put("canonicalID", canonicalID );
		nString = new String(replaceID(nString, canonicalID, thisSVGres, "resID", "R", accession, "") );
		lString = new String(replaceID(lString, canonicalID, thisSVGres, "linkID", "L", accession, "") );
		aString = new String(replaceID(aString, canonicalID, thisSVGres, "annID", "LI", accession, "") );
		// no IDs for annotations
		// aString = new String(replaceID(aString, canonicalID, thisSVGres, "annID", "LI", accession) );

	
		// get children of current residues, check for this parent, then linkage site
		for (String gtKey : gtMap.keySet()) {
			Map<String, String> gtRes = gtMap.get(gtKey);
			if(gtRes.containsKey("parent") ) {
				String gtParent = gtRes.get("parent");
				if (gtParent.matches(thisGTres.get("id") ) ) {
					// thisGTres is parent of gtRes
					for (String svgKey : svgMap.keySet() ) {
						Map<String, String>svgRes =svgMap.get(svgKey);
						if(svgRes.containsKey("parent") ) {
							String svgParent = svgRes.get("parent");
							String thisID = thisSVGres.get("id");
							if ( (thisID != null) && (svgParent.matches(thisID) )  ){
								// thisSVGres is parent of svgRes
								// now, compare site of the parallel children (gtRes, svgRes)
								if (gtRes.get("site").matches(svgRes.get("site") )  ) {
									if (v > 5) System.out.printf("\n    Recursion:  mapped glycoTree residue %s to SVG residue %s",
											gtRes.get("id"), svgRes.get("id"));
									// !! RECURSION !! passing the two matching children
									mapTheIDs(gtMap, svgMap, gtRes, svgRes, accession);
								}
							}
						}// recursion
					}
				}
			}
		}
		
		
	} //end of method mapTheIDs()
	
	
	/**
	 * adds a new Map (i.e., residue) to the Map of Maps containing the svg-encoded residues - modifies
	 * the HashMap that contains parameters describing the svg-encoded residues
	 * @param gID the id of the &lt;g&gt; element in the original svg encoding of the structure
	 * @param svgResidues the Map of Maps containing the svg-encoded residues
	 * @return the numerical index of the new residue. E.g., when gID="r-1:7" the value "7" is returned
	 */
	public static String addResidue(String gID, Map<String, Map<String, String>> svgResidues) {
		String[] keySplit = gID.split(":")[1].split(","); 
    	String key = keySplit[keySplit.length-1	];
    	if (!svgResidues.containsKey(key)) { // the residue has not yet been added to the Map
    		Map<String, String> resMap = new HashMap<String, String>();
    		svgResidues.put(key, resMap);
    	}
		
		return(key);
	} // end of method addResidue()
	
	
	
	
	/**
	 * processes residue (R) nodes in the svg encoding to generate a String to be included in 
	 * the newly-generated svg encoding
	 * @param gID the svg ID of the residue node that is being processed
	 * @param childNodes a list of the children of the residue &lt;g&gt; element in the original svg file
	 * @param gStr a String holding the residue &lt;g&gt; element in the original svg file
	 * @param residue the svg residue (HashMap) being processed
	 * @param index a String representation of the index of the svg residue. This is a unique
	 * key in the context of an individual svg encoding - for example, when gID="r-1:4", key="4"
	 * @return a String holding the newly generated residue &lt;g&gt; element and enclosed shape elements
	 * (e.g., &lt;rect&gt;, &lt;circle&gt;) - in rare cases, the svg "R" element just contains a supplemental
	 * annotation string (like "6S"), in which case an svg &lt;text&gt; element is generated
	 */
	public static String type_R(String gID, NodeList childNodes, String gStr, Map<String, String> residue, String index) {
		// generates a shape node (circle, rect, polygon) to replace the bloated shape definitions
		
		if (v > 3) {
			System.out.printf("\n    Properties:" );
		}
		String style = "stroke:black; ";

		// get and set attributes of the first child
		String shapeAtts = "";
		Node fcn = childNodes.item(0);
		Element fce = (Element) fcn;
		NamedNodeMap fcAtts = fce.getAttributes();
		
		for (int j = 0; j < fcAtts.getLength(); j++ ) {
			if (fcAtts.item(j).getNodeName().compareTo("style") !=0) { // style redefined above
				if (v > 3) System.out.printf("\n      %s", fcAtts.item(j));
				shapeAtts = shapeAtts.concat(" " + fcAtts.item(j).toString());
			}
		}
		
		// loop through children to find rgb and use it to form the style of the first child
		if (v > 3) System.out.printf("\n    Children:");
		for (int i = 0; i < childNodes.getLength(); i++ ) {
			Element child = (Element) childNodes.item(i);

			String shapeName = child.getNodeName();
			if (v > 3) System.out.printf("\n       shape: <%s>", shapeName);

			if (shapeName.matches("path")) { 
				// there is a path inside an "R" element - extract information and prevent drawing the <rect> (useless in this case) 
				String dStr = child.getAttribute("d").toString();
				// map and display the path string
				Map<String, String> tp = new HashMap<String, String>();

				try {
					tp = mapChar(dStr);
				} catch (Exception e) {
					e.printStackTrace();
					return("");
				}

				String textNodeStr = "<text style=\"fill:black; stroke:none; " +
						" font-size:" + tp.get("size") + "; font-family:'" + tp.get("font") + "';\" x=\"" + tp.get("x") +
						"\" y=\"" + tp.get("y") + "\" text-anchor=\"middle\">" + tp.get("char") + "</text>"; 
				// remove id from svg text (which could be redundant inside any enclosing <html>) from gStr
				String gStrAlt = "\n    <g style=\"fill:white; text-rendering:optimizeSpeed;\" >" ;
				String textStr = gStrAlt + "\n      " + textNodeStr + "\n    </g>";
				if (v > 3) System.out.printf("\n    textStr:      %s", textStr);

				// bail out of R_type() method - no shape drawing is appropriate for this svg element
				return(textStr);
			}

			String childStyle = child.getAttribute("style");
			Boolean macho = childStyle.matches("(.*)rgb(.*)");
			if (macho) {  // if the child has an rgb string in its style string
				Pattern pattern = Pattern.compile("rgb\\(([^\\)]*)\\)");
				Matcher matcher = pattern.matcher(childStyle);
				if (matcher.find()) {
					String rgb = matcher.group(0);
					residue.put("color", rgb);
					if (v > 4) System.out.printf("\n        adding node color %s to residue", rgb);
					style = style.concat("fill:" + rgb + ";");	    
				}
				// get and save coordinates to generate reducing end anomer annotation
				NamedNodeMap childAtts = child.getAttributes();
				String x = childAtts.getNamedItem("x").toString().split("\"")[1];
				String y = childAtts.getNamedItem("y").toString().split("\"")[1];
				if (v > 3)	System.out.printf("\n&&& coordinates for residue[%s] are (%s,%s)", index, x, y);
				residue.put("x", x);
				residue.put("y", y);
			}
		}
		
    	residue.put("resID", gID);
    	residue.put("id", index);

		String shapeStr = gStr + "\n      <" + fcn.getNodeName() + " style=\"" + style + "\" " + shapeAtts + "/>\n    </g>";
		if (v > 3) System.out.printf("\n    new style: %s\n    shapeStr:      %s", style, shapeStr);

		return(shapeStr);
	} // end of method type_R()
	
	
	/**
	 * processes link nodes (edges) in the svg encoding
	 * @param gID the svg ID of the link node
	 * @param childNodes a list of the children of the link &lt;g&gt; element in the original svg file
	 * @param gStr a String holding the link &lt;g&gt; element in the original svg file
	 * @param residue a Map defining the properties of the svg residue
	 * @return a String holding the newly generated link &lt;g&gt; element and enclosed edge element
	 * (encoded as a &lt;polygon&gt;)
	 */
	public static String type_L(String gID, NodeList childNodes, String gStr, Map<String, String> residue) {
		if (v > 3) {
			System.out.printf("\n    Properties:" );
		}
		
		// get and set attributes of the first child
		String shapeAtts = "";
		Node fcn = childNodes.item(0);
		Element fce = (Element) fcn;

		NamedNodeMap fcAtts = fce.getAttributes();
		for (int j = 0; j < fcAtts.getLength(); j++ ) {
			if (v > 3) System.out.printf("\n      %s", fcAtts.item(j));
			shapeAtts = shapeAtts.concat(" " + fcAtts.item(j).toString());
		}
		String linkStr = gStr + "\n      <" + fcn.getNodeName() + " " + shapeAtts + "/>\n    </g>";
		
		String[] idSplit = gID.split(":")[1].split(","); 
    	String parent = idSplit[0];
    	if (v > 3) {
    		System.out.printf("\n    linkStr:      %s", linkStr);
        	System.out.printf("\n    adding parent %s to residue", parent);
        	System.out.printf("\n    adding linkID %s to residue", gID);
    	}
		
		// add site to residue
    	residue.put("parent",  parent);
    	residue.put("linkID", gID);

		return(linkStr);
	}  // end of method type_L()
	
	/**
	 * process "B" elements (paths corresponding to brackets) in the svg encoding
	 * @param childNodes the child elements of a type-B &lt;g&gt; element from the svg encoding
	 * @param gStr a String holding the svg encoding of the &lt;g&gt; element in the original file
	 * @return a String holding the &lt;g&gt; element and enclosed path specifying the bracket
	 */
	public static String type_B(NodeList childNodes, String gStr) {
		if (v > 3) {
			System.out.printf("\n    Properties:" );
		}
		
		// get and set attributes of the first child
		String shapeAtts = "";
		Node fcn = childNodes.item(0);
		Element fce = (Element) fcn;

		NamedNodeMap fcAtts = fce.getAttributes();
		for (int j = 0; j < fcAtts.getLength(); j++ ) {
			if (v > 3) System.out.printf("\n      %s", fcAtts.item(j));
			shapeAtts = shapeAtts.concat(" " + fcAtts.item(j).toString());
		}
		String bStr = gStr + "\n      <" + fcn.getNodeName() + shapeAtts + "/>\n    </g>";

		return(bStr);
	} // end of method type_B()
	
	
	/**
	 * processes annotation nodes (e.g., "alpha" and "6") in the svg encoding
	 * @param gID the svg ID of the annotation node - ultimately, another method will replace this 
	 *  with a semantic ID
	 * @param childNodes a list of the children of the (LI) annotation &lt;g&gt; element in the original svg file
	 * @param gStr a String holding the annotation &lt;g&gt; element in the original svg file
	 * @param residue the svg residue (encoded as a HashMap)
	 * @return a String holding the newly generated link-annotation &lt;g&gt; element and enclosed text elements
	 */
	public static String type_LI(String gID, NodeList childNodes, String gStr, Map<String, String> residue) {
		
		String annotationStr = gStr;
		String site = "";

		if (v > 3) System.out.printf("\n    Children:");
		for (int i = 0; i < childNodes.getLength(); i++ ) {
			String nodeName = childNodes.item(i).getNodeName();
			if (v > 3) System.out.printf("\n      <%s>", nodeName);

			if (nodeName.matches("path")) { 
				// convert path to explicit ascii character(s)
				Element thisNode = (Element) childNodes.item(i);

				String dStr = thisNode.getAttribute("d").toString();
				// tp holds text parameters
				Map<String, String> tp = new HashMap<String, String>();

				try {
					tp = mapChar(dStr);
				} catch (Exception e) {
					e.printStackTrace();
					return(gStr + "</g>");
				}

				if ( tp.get("char").matches("[0-9]") ) { 
					// tp.get("char") is a single-digit number, i.e., a unique site
					site = tp.get("char");
				}
				String textStr = "\n      <text style=\"fill:black; stroke:none; " +
						" font-size:" + tp.get("size") + "; font-family:'" + tp.get("font") + "';\" x=\"" + tp.get("x") +
						"\" y=\"" + tp.get("y") + "\" text-anchor=\"middle\">" + tp.get("char") + "</text>"; 
				annotationStr += textStr;
			}
		}


		if (v > 4) {
			System.out.printf("\n    adding link site %s to residue", site);
			System.out.printf("\n    adding annID %s to residue", gID);
		}
		residue.put("site", site);
		residue.put("annID", gID);
		annotationStr += "\n    </g>";
		if (v > 3) System.out.printf("\n    annotationStr:      %s", annotationStr);

		return(annotationStr);	
	} // end of method type_LI()
	
	
	/**
	 * maps the "d" attribute of an svg &lt;path&gt; used in the original svg encoding to render a character to
	 * a set of parameters specifying the attributes of an svg &lt;text&gt; element used in the newly-generated
	 * svg encoding to render the same character
	 * @param dStr a String holding the "d" attribute of an svg &lt;path&gt; used in the original svg encoding to 
	 * render a character 
	 * @return a HashMap containing the information ("char", "dx", "x", "dy", "y", "font", and "size")
	 * required to generate a &lt;text&gt; element used to render the character in the newly-generated svg encoding
	 * @throws Exception thrown when dStr cannot be mapped to a character
	 */
	public static HashMap<String, String> mapChar(String dStr) throws Exception {
		String[] data = dStr.split(" ");
		
		// dMapStr is a string of non-numeric characters that represents the character without reference to size or position
		// the first part of dMapStr is the number of data points in dStr (separated by " ")
		String dMapStr = String.format("%d", data.length);

		for (int i = 0; i < data.length; i++) {
			// look for an alphabet character at start of each data point
			Pattern pattern = Pattern.compile("^[A-Za-z]");
			Matcher matcher = pattern.matcher(data[i]);
			if (matcher.find()) {
				// extend dMapStr
				dMapStr += matcher.group(0);    
			}
		}
			
		PathMapper mapper = PathMapper.forName(dMapStr);
		String c = mapper.getChar();
		String dx = mapper.getdx();
		String dy = mapper.getdy();
		String font = mapper.getFont();
		String size = mapper.getSize();
		
		Double x = Double.parseDouble(data[0].substring(1, data[0].length()) );
		x += Double.parseDouble(dx);
		x = Math. round(x * 10) / 10.0;
		// Double xStr = (Double)x;
		Double y = Double.parseDouble(data[1]);
		y += Double.parseDouble(dy);
		y = Math. round(y * 10) / 10.0;

		if (v > 3) {
			System.out.printf("\n         dMapStr %s\n          mapped to String '%s'",  dMapStr, c);
			System.out.printf("\n          dx is %s", dx );
			System.out.printf("\n          x is %s", x );			
			System.out.printf("\n          dy is %s", dy );			
			System.out.printf("\n          y is %s", y );			
			System.out.printf("\n          font is %s", font );			
			System.out.printf("\n          size is %s", size );			
		}
		
		HashMap<String,String> result = new HashMap<String, String>();
		result.put("char", c );
		result.put("dx", dx );
		result.put("x", x.toString() );
		result.put("dy", dy );
		result.put("y", y.toString() );
		result.put("font", font );
		result.put("size", size );
		
		return(result);
	}
}
