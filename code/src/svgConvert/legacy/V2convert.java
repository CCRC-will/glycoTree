package svgConvert;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;

import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner; 

/**
 * V2convert parses an svg file produced by GlyTouCan and generates another svg file that
 * generates essentially the same image, while removing unnecessary object layering and
 * assigning unique id attributes of each shape node, edge, and text annotation in the image.
 * This allows more than one svg image to be rendered in a single browser window and facilitates
 * programmatic access (e.g., click events) to each svg element by javascript code.
 * The id's are generated by reference to a json file that maps the id's in the original svg
 * file to residues in a canonical representation of glycan structure.
 * <br>
 *  Copyright 2020 William S York
 *  <br>
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  <br>
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  <br>
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.
 * <br>
 * @author wsyork
 *
 */
public class V2convert {
	
	
	/**
	 * the verbosity of the output to stdout
	 */
	public static int v = 9;


	/**
	 * The core execution method, that collects data and generates svg output.
	 * Command line arguments (args):<br>
	 * -l: the full file name containing a list of svg input files to process<br>
	 * -s: the name of a single svg file encoding a glycan image to process<br>
	 * -a: a String specifying the version of the output (e.g., "v2.0") - used in
	 * naming the output file to prevent file-name degeneracy<br>
	 * -j: the name of the directory holding the json files used in batch processing -
	 * if -j is not specified, json files are fetched from the same directory that
	 * holds the corresponding svg input file<br>
	 * -o: the name of the directory to which the generated svg files are written -
	 * if -o is not specified, svg files are written to the same directory that
	 * holds the corresponding svg input file<br>
	 * -v: verbosity has a value of 0-9. For batch processing, use "-v 0" so very
	 * litte information is provided to std out<br>
	 * @param args	 An array of parameters passed to the program at initiation
	 */
	public static void main(String args[]) {
		String svgFileName = "";
		String listFileName = null;
		String outDir = "./";
		Boolean outDirSet = false;
		String jsonDir = "";
		Boolean jsonDirSet = false;
		String versionStr = "unbloated";
		Boolean versionSet = false;
		
		String svgEncoding = "";

		// get command line arguments
		for (int i = 0; i < args.length; i++) {
			char c1 = args[i].charAt(0);
			char c2 = '0';
			if (args[i].length() > 1)
				c2 = args[i].charAt(1);
			// String s = "";
			// if (i < args.length - 1) s = args[i+1];
			// System.out.printf("%d: %s (%s)\n", i, args[i], s);
			if (c1 == '-') {
				switch (c2) {
					case 's':
						i++;
						svgFileName = args[i];
						break;
					case 'l':
						i++;
						listFileName = args[i];
						break;
					case 'a':
						i++;
						versionStr = args[i];
						// versionSet = true;
						break;
					case 'j':
						i++;
						jsonDir = args[i];
						jsonDirSet = true;
						break;
					case 'o':
						i++;
						outDir = args[i];
						outDirSet = true;
						break;
					case 'v':
						i++;
						v = Integer.valueOf(args[i]);
						break;
					default:
						break;
				}
			}
		}
		
		/**
		 * an ArrayList of the svg files to be processed
		 */
		ArrayList<String> files = new ArrayList<String>();
		if (listFileName != null) {
			// open and parse the list file, putting elements in the ArrayList "files"
			if (v > 0)
				System.out.printf("\n\n###### Using a list (%s) containing input files ######\n", listFileName);
			files = parseListFile(listFileName);
		} else if (svgFileName != null) {
			if (v > 0)
				System.out.printf("\n\n###### Using a single specified input file (%s) ######\n", svgFileName);
			// just put the svgFileName into the files ArrayList
			files.add(svgFileName);
		} else {
			System.out.printf("** No valid svg input files ** \n");
		}

		for (Iterator<String> f_iter = files.iterator(); f_iter.hasNext();) {
			svgFileName = f_iter.next(); // keep this for later use
			File inFile = new File(svgFileName);
			String inputDir = inFile.getParent();
			String inputFileName = inFile.getName();
			String[] dotSplit = inputFileName.split("[.]");
			if (!jsonDirSet) jsonDir = new String(inputDir);
			String jsonFileName = jsonDir + "/" + dotSplit[0] + ".json";
			if (!outDirSet) outDir = new String(inputDir);
			// if (!versionSet) versionStr = new String(inputDir);
			String outFileName = outDir + "/" + dotSplit[0] + "." + versionStr + ".svg";
			// still need to generate the out file, including version ...

			if (v > 0) System.out.printf("\n\n#### Processing %s ####", inputFileName);

			if (v > 3) {
				System.out.printf("\n  svg full fileName: %s", svgFileName);
				System.out.printf("\n  inputDir: %s", inputDir);
				System.out.printf("\n  jsonFileName: %s", jsonFileName);
				System.out.printf("\n  outFileName: %s", outFileName);
			}
			svgEncoding = processSVGfile(jsonFileName, svgFileName );	
			if (v > 3) System.out.printf("\n\n%s\n",svgEncoding);
			writeData(svgEncoding, outFileName);
			// output svgEncoding to output file
		}
		
	} // end of main()
	
	/**
	 * Generates a list of file names by reading an input file whose name is specified by the String fn
	 * @param fn A String containing the name of a file listing  input (svg) files  
	 * @return An ArrayList containing names of svg input file for processing
	 */
	public static ArrayList<String> parseListFile(String fn) {
		ArrayList<String> result = new ArrayList<String>();
		File file = new File(fn);
		if (file.exists()) {
			try {
				Scanner input = new Scanner(file);
				while (input.hasNext()) {
					String line = input.next();
					result.add(line);
					if (v > 5)
						System.out.printf("\nAdding file %s", line);
				}
				input.close();
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} else {
			System.out.printf("file %s does not exist", fn);
		}
		return (result);
	} // end of parseListFile


	/**
	 * Writes String strToWrite to file instantiated with fileName
	 * @param strToWrite the String to be written
	 * @param fileName the name of the file to be written to
	 */
	public static void writeData(String strToWrite, String fileName) {
		if (v > 3)
			System.out.printf("\n# Writing to file: %s", fileName);
		try {
			BufferedWriter w = new BufferedWriter(new FileWriter(fileName));
			w.write(strToWrite);
			w.close();
		} catch (IOException e) {
			e.printStackTrace();
			System.out.printf("IO exception for file %s\n", fileName);
		}
	} // end of writeData()
	
	/**
	 * parses an input svg file and generates a new svg file in which unnecessary
	 * layering has been removed and svg objects have been assigned unique id's,
	 * based on information contained in the corresponding json file
	 * @param jFileName the name of the json file to process
	 * @param sFileName the name of the svg file to process
	 * @return a String (to be written to a new svg file) that encodes the new svg image
	 */
	public static String processSVGfile(String jFileName, String sFileName ) {
		
		String svgStr = "";

		
		// json processing variables
		/**
		 * a HashMap associating the residue node id's in the original svg file to canonical glycan residues
		 */
	    Map<String, String> canResIDs= new HashMap<String, String>();

		/**
		 * a HashMap associating the edge id's in the original svg file to canonical glycan residues
		 */
	    Map<String, String> canLinkIDs= new HashMap<String, String>();
	    
		/**
		 * a HashMap associating the linkage annotation id's in the original svg file to canonical glycan residues
		 */
	    Map<String, String> canAnnIDs= new HashMap<String, String>();
		
	    // svg processing variables
	    
	    /**
	     * a StringBuilder that holds encoding of all newly-generated edge nodes (linkages)
	     */
	    StringBuilder lStr = new StringBuilder(); 
	    
	    /**
	     * a StringBuilder that holds encoding of all newly-generated residue nodes
	     */
		StringBuilder nStr = new StringBuilder();  
		
	    /**
	     * a StringBuilder that holds encoding of all newly-generated link annotation nodes
	     */		
		StringBuilder aStr = new StringBuilder();  
		
	    /**
	     * a StringBuilder that holds the first lines of the new svg file (e.g., header information)
	     */	
		StringBuilder headStr = new StringBuilder(); 
		
	    /**
	     * a StringBuilder that holds the last lines of the new svg file (e.g., tag closings)
	     */	
		StringBuilder tailStr = new StringBuilder("\n  </g>\n</svg>\n<!-- ## End of svg encoding ##-->\n\n");


       // ###### process json ######
		if (v > 0) {
			System.out.printf("\n\n### Processing json file [%s] ###", jFileName);
		}
		
		try {
	        Object obj = new JSONParser().parse(new FileReader(jFileName)); 
            JSONArray root = (JSONArray) obj;
            // System.out.printf("\n%s", root.toString());
            Iterator it = root.iterator(); 
            
            int count = 0;
            while (it.hasNext())  { 
                HashMap<String, String> resRecord = new HashMap<String, String>();
                String which = String.valueOf(count++);  
            	Iterator<Map.Entry> it2 = ((Map) it.next()).entrySet().iterator(); 
            	String rKey = "";
            	String lKey = "";
            	String aKey = "";
            	String canID = "";
                while (it2.hasNext()) { 
                    Map.Entry pair = it2.next(); 
                    if (pair.getKey().toString().compareTo("SVG_g_element_ID_residue") == 0) {
                    	rKey = pair.getValue().toString();
                    }
                    if (pair.getKey().toString().compareTo("SVG_g_element_ID_linkage_annotation") == 0) {
                    	aKey = pair.getValue().toString();
                    }
                    if (pair.getKey().toString().compareTo("SVG_g_element_ID_linkage") == 0) {
                    	lKey = pair.getValue().toString();
                    }
                    if (pair.getKey().toString().compareTo("canonical_residue") == 0) {
                    	String canResName = pair.getValue().toString();
                    	String[] canResSplit = canResName.split("_");
                    	canID = canResSplit[0].substring(0, 1) + canResSplit[canResSplit.length - 1];
                    	if (v > 3) 
                    		System.out.printf("\n  canonical residue  '%s'  with  ID '%s'", canResName, canID);
                    }
                } 
                
                if (v > 3) 
                	System.out.printf("\n    Keys: '%s'; '%s'; '%s'\n", rKey, lKey, aKey); 

                canResIDs.put(rKey, canID);
                canLinkIDs.put(lKey, canID);
                canAnnIDs.put(aKey, canID);
            } 
        } catch (Exception e) {
            e.printStackTrace();
        }
        

		// ##### process svg #####
		
		// find accession by splitting the svgFileName
		String[] fnPath = sFileName.split("[/]");
		String fn = fnPath[fnPath.length - 1];
		String accession = fn.split("[.]")[0];
		
		headStr.append("<?xml version=\"1.0\"?>\n" +
			"<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.0//EN' 'http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd'>");
		headStr.append("\n<!-- ## svg encoding translated from file " + fn + " ## -->");


		if (v > 0) {
			System.out.printf("\n\n### Processing svg file [%s] ###", sFileName);
			System.out.printf("\n  Accession: %s", accession);
		}
		
		
		try {

			File svgFile = new File(sFileName);
			DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			
			// override downloading the DTD
			dbFactory.setValidating(false);
			dbFactory.setNamespaceAware(true);
			dbFactory.setFeature("http://xml.org/sax/features/namespaces", false);
			dbFactory.setFeature("http://xml.org/sax/features/validation", false);
			dbFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-dtd-grammar", false);
			dbFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);

			
			
			DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			Document doc = dBuilder.parse(svgFile);
			Node sNode = doc.getDocumentElement();
			sNode.normalize();
			Element svgElement = (Element) sNode;
			String svgStyle = svgElement.getAttribute("style");
			if (v > 3) {
				System.out.printf("\n  Root Node is a <%s> tag", sNode.getNodeName());
				System.out.printf("\n  svgStyle:\n   %s", svgStyle);
			}
			


			NodeList gList = svgElement.getElementsByTagName("g");
			int tCount = 1;
			// could do mapping here without Wenjin's input json file by iterating over the <g> nodes
			//  then generating a tree with nodes labeled with gID values
			//    nodes identified by evaluating color (rgb) and shape (rect|circle|polygon) 
			//          of <g> nodes of type "R"
			//    parent of each node identified by evaluating <g> nodes of type "L",
			//        assuming the root residue has ID = 1
			//    anomeric and linkage position identified by evaluating characters extracted from <g> nodes
			//       of type "LI"
			//    depth first traversal of glycoTree representation and this tree should facilitate mapping
			//    object ID's can be replaced in svgString after the fact (e.g. replace "r-1:6" with ID 
			//      calculated for node 6, like this:  
			//        svgStr.replace("id=\"r-1:6\"", "id=\"WHATEVER\"");
			for (int gItem = 0; gItem < gList.getLength(); gItem++) {
				Node gNode = gList.item(gItem);
				if (v > 3) System.out.printf("\n\n\n  <%s> Element[%d]:", gNode.getNodeName(), gItem);

				if (gNode.getNodeType() == Node.ELEMENT_NODE) {
					Element gElement = (Element) gNode;

		        	String gStyle = gElement.getAttribute("style");
		        	String gStr = "\n    <g style=\"" + gStyle + "\">";
		        	// get the descendants of gElement 
		    		NodeList ch = gElement.getElementsByTagName("*");
		    		
			        Boolean gHasID = gElement.hasAttribute("ID");
			        if (gHasID) {
			        	String gID = gElement.getAttribute("ID");

			        	// parse the ID
			        	String gType = gID.split("-")[0].toUpperCase();	
			        	
			        	
			        	if (v > 3) {
			        		System.out.printf("\n    gID is %s", gID);
			        		System.out.printf("\n    gStyle is %s", gStyle);
			        		System.out.printf("\n    gType is %s", gType);
			        		System.out.printf("\n    accession is %s", accession);
			        	}
			        	


			        	// switch on value of gType
			    		String newID = "";
			        	switch (gType) {
			        	case "R": // gElement wraps a residue
				        	newID = String.format("%s-%s:%s", gType, accession, canResIDs.get(gID));
			        		nStr.append(type_R(newID, ch, gStr) );
			        		break;
			        	case "L": // gElement wraps a link
				        	newID = String.format("%s-%s:%s", gType, accession, canLinkIDs.get(gID));
			        		lStr.append(type_L(newID, ch, gStr) );
			        		break;
			        	case "LI": // gElement wraps a link annotation
			        		aStr.append(type_LI(accession, canAnnIDs.get(gID), ch, gStr) );
			        		break;
			        	default:
			        	}
			        	

			        } else { // the <g> Element has no ID
			        	Node fcn = gElement.getFirstChild();
			        	Element fce = (Element) fcn;

			        	String fcnType = fcn.getNodeName();
			        	if (v > 3) {
			        		System.out.printf("\n    no ID Attribute");
				        	System.out.printf("\n    first child Node is a <%s>", fcnType);
			        	}

			        	// the dimensions of the image are defined by a <g> tag with no id and whose first child is a <rect> 
			        	if (fcnType.compareTo("rect") == 0) {
			        		String h = fce.getAttribute("height");
			        		String w = fce.getAttribute("width");

			        		String temp = "\n<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n  height=\"" + 
			    					h + "\" width=\"" + w + "\"\n  style=\"" + svgStyle + "\" >";
			        		if (v > 3) {
			        			System.out.printf("\n    Image boundary <rect>\n      height: %s\n      width: %s", h, w);
			        			System.out.printf("\n    <svg> tag string:%s", temp);
			        		}
			        		headStr.append(temp); 
			    			headStr.append("\n  <g>");
			        	}
			        	
			        	// some text is defined as a path, with no associated id
			        	if (fcnType.compareTo("path") == 0) {
			        		String tIndex = "text" + tCount++;
			        		// if (v > 3) 
			        			System.out.printf("\n    found unindexed text (%s)", tIndex);
			        		aStr.append(type_LI(accession, tIndex, ch, gStr) );
			        	}


			        }
					// NodeList pathList = eElement.getElementsByTagName("path");

				}
			}
			
			svgStr = String.format("%s%s%s%s%s\n", headStr, lStr, nStr, aStr, tailStr);
			
		} catch (Exception e) {
			e.printStackTrace();
		}

		return(svgStr);
	}   

	/**
	 * processes residue nodes in the svg encoding
	 * @param id the newly generated id of the residue node
	 * @param childNodes a list of the children of the residue &lt;g&gt; element in the original svg file
	 * @param gStr a String holding the residue &lt;g&gt; element in the new svg file
	 * @return a String holding the newly generated residue &lt;g&gt; element and enclosed shape elements
	 * (e.g., &lt;rect&gt;, &lt;circle&gt;), which have been assigned unique ids
	 */
	public static String type_R(String id, NodeList childNodes, String gStr) {
		// generates a shape node (circle, rect, polygon) to replace the bloated shape definitions
		
		if (v > 3) System.out.printf("\n    Properties:", id );
		String style = "stroke:black; ";

		// get and set attributes of the first child
		String shapeAtts = "";
		Node fcn = childNodes.item(0);
		Element fce = (Element) fcn;
		NamedNodeMap fcAtts = fce.getAttributes();
		for (int j = 0; j < fcAtts.getLength(); j++ ) {
			if (fcAtts.item(j).getNodeName().compareTo("style") !=0) { // style redefined above
				if (v > 3) System.out.printf("\n      %s", fcAtts.item(j));
				shapeAtts = shapeAtts.concat(" " + fcAtts.item(j).toString());
			}
		}
		// loop through children to find rgb and use it to form the style of the first child
		if (v > 3) System.out.printf("\n    Children:");
		for (int i = 0; i < childNodes.getLength(); i++ ) {
			if (v > 3) System.out.printf(" <%s>", childNodes.item(i).getNodeName());
			Element child = (Element) childNodes.item(i);
			String childStyle = child.getAttribute("style");
			Boolean macho = childStyle.matches("(.*)rgb(.*)");
			if (macho) {  // if the child has an rgb string in its style string
				Pattern pattern = Pattern.compile("fill:rgb\\(([^\\)]*)\\)");
				Matcher matcher = pattern.matcher(childStyle);
				if (matcher.find()) {
					String rgb = matcher.group(0);
					style = style.concat(rgb);	    
				}
			}
		}
		

		String shapeStr = gStr + "\n      <" + fcn.getNodeName() + " id=\"" + id +
				"\" style=\"" + style + "\" " + shapeAtts + "/>\n    </g>";
		if (v > 3) System.out.printf("\n    new style: %s\n    shapeStr:      %s", style, shapeStr);

		return(shapeStr);
	}
	
	
	/**
	 * processes link nodes (edges) in the svg encoding
	 * @param id the newly generated id of the link node
	 * @param childNodes a list of the children of the link &lt;g&gt; element in the original svg file
	 * @param gStr a String holding the link &lt;g&gt; element in the new svg file
	 * @return a String holding the newly generated link &lt;g&gt; element and enclosed edge element
	 * (encoded as a &lt;polygon&gt;), which has been assigned a unique id
	 */
	public static String type_L(String id, NodeList childNodes, String gStr) {
		if (v > 3) System.out.printf("\n    Properties:", id );
		
		// get and set attributes of the first child
		String shapeAtts = "";
		Node fcn = childNodes.item(0);
		Element fce = (Element) fcn;

		NamedNodeMap fcAtts = fce.getAttributes();
		for (int j = 0; j < fcAtts.getLength(); j++ ) {
			if (v > 3) System.out.printf("\n      %s", fcAtts.item(j));
			shapeAtts = shapeAtts.concat(" " + fcAtts.item(j).toString());
		}
		String linkStr = gStr + "\n      <" + fcn.getNodeName() + " id=\"" + id +
				 "\" " + shapeAtts + "/>\n    </g>";
		if (v > 3) System.out.printf("\n    linkStr:      %s", linkStr);

		return(linkStr);
	}
	
	
	/**
	 * processes link annotation nodes (e.g., "alpha" and "6") in the svg encoding
	 * @param accession a String holding the GlyTouCan accession of the glycan whose svg image is being processed
	 * @param canID a String holding the canonical id for the residue whose link annotation is being processed
	 * @param childNodes a list of the children of the annotation &lt;g&gt; element in the original svg file
	 * @param gStr a String holding the annotation &lt;g&gt; element in the new svg file
	 * @return a String holding the newly generated link-annotation &lt;g&gt; element and enclosed text elements,
	 * which have been assigned unique id's
	 */
	public static String type_LI(String accession, String canID, NodeList childNodes, String gStr) {
		
		String annotationStr = gStr;
		int count = 0;

		if (v > 3) System.out.printf("\n    Children:");
		for (int i = 0; i < childNodes.getLength(); i++ ) {
			String nodeName = childNodes.item(i).getNodeName();
			if (v > 3) System.out.printf("\n      <%s>", nodeName);

			if (nodeName.compareTo("path") == 0) {
				count++;
				Element thisNode = (Element) childNodes.item(i);
				NamedNodeMap atts = thisNode.getAttributes();

				for (int j = 0; j < atts.getLength(); j++ ) {
					// parse atts.item(j) to get attribute "d", and use this for character mapping
					if (atts.item(j).getNodeName().compareTo("d") == 0) {
						String id = String.format("LI-%d-%s:%s", count, accession, canID);
						String[] thisAtt = atts.item(j).toString().split("\"");
						String dStr = thisAtt[1];
						String[] data = dStr.split(" ");
						try {
							// get the mapping parameters for the d attribute
							HashMap<String, String> hm = mapChar(dStr);
							// the reference x coordinate is in the zeroth element of data[]
							double x = Double.parseDouble(data[0].substring(1, data[0].length()) );
							// dx is retrieved from pathMapper
							double dx = Double.parseDouble(hm.get("dx") );
							x += dx;
							x = Math. round(x * 10) / 10.0;
							double y = Double.parseDouble(data[1]);
							double dy = Double.parseDouble(hm.get("dy") );
							y += dy;
							y = Math. round(y * 10) / 10.0;
							String ff = hm.get("font");
							String fs = hm.get("size");

							// create <text> tag matching path (using mapChar - pathMapper)
							annotationStr += "\n      <text id=\"" + id + "\" style=\"fill:black; stroke:none; " +
									" font-size:" + fs + "; font-family:'" + ff + "';\" x=\"" + x + "\" y=\"" + y + "\" text-anchor=\"middle\" >"; 

							annotationStr += hm.get("char") + "</text>";
						} catch (Exception e) {
							e.printStackTrace();
						}

					}
				}
			}
		}

		annotationStr += "\n    </g>";
		if (v > 3) System.out.printf("\n    annotationStr:      %s", annotationStr);

		return(annotationStr);	
	}
	
	/**
	 * maps the "d" attribute of an svg &lt;path&gt; used in the original svg encoding to render a character to
	 * a set of parameters specifying the attributes of an svg &lt;text&gt; element used in the newly-generated
	 * svg encoding to render the same character
	 * @param dStr a String holding the "d" attribute of an svg &lt;path&gt; used in the original svg encoding to render a character 
	 * @return a HashMap containing the information required to generate a &lt;text&gt; element used to render
	 * the character in the newly-generated svg encoding
	 * @throws Exception thrown when dStr cannot be mapped to a character
	 */
	public static HashMap<String, String> mapChar(String dStr) throws Exception {
		String[] dArray = dStr.split(" ");
		
		// the first part of dMapStr is the number of data points in dStr (separated by " ")
		String dMapStr = String.format("%d", dArray.length);

		for (int i = 0; i < dArray.length; i++) {
			// look for an alphabet character at start of each data point
			Pattern pattern = Pattern.compile("^[A-Za-z]");
			Matcher matcher = pattern.matcher(dArray[i]);
			if (matcher.find()) {
				// extend dMapStr
				dMapStr += matcher.group(0);    
			}
		}

		
		PathMapper mapper = PathMapper.forName(dMapStr);
		if (v > 3) {
			System.out.printf("\n       dMapStr is %s",  dMapStr);
			System.out.printf("\n        Character is %s", mapper.getChar() );
			System.out.printf("\n        dx is %s", mapper.getdx() );
			System.out.printf("\n        dy is %s", mapper.getdy() );			
			System.out.printf("\n        font is %s", mapper.getFont() );			
			System.out.printf("\n        size is %s", mapper.getSize() );			
		}
		
		HashMap<String,String> result = new HashMap<String, String>();
		result.put("char", mapper.getChar() );
		result.put("dx", mapper.getdx() );
		result.put("dy", mapper.getdy() );
		result.put("font", mapper.getFont() );
		result.put("size", mapper.getSize() );

		
		return(result);
	}
}
